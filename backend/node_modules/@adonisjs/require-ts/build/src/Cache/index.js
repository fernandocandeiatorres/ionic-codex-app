"use strict";
/*
 * @adonisjs/require-ts
 *
 * (c) Harminder Virk <virk@adonisjs.comharminder@cav.ai>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FakeCache = exports.Cache = void 0;
const path_1 = require("path");
const rev_hash_1 = __importDefault(require("rev-hash"));
const fs_extra_1 = require("fs-extra");
const utils_1 = require("../utils");
/**
 * Exposes the API to write file parsed contents to disk as cache. Handles
 * all the complexity of generate correct paths and creating contents
 * hash
 */
class Cache {
    constructor(appRoot, cacheRoot) {
        this.appRoot = appRoot;
        this.cacheRoot = cacheRoot;
    }
    /**
     * Generates hash from file contents
     */
    generateHash(contents) {
        return (0, rev_hash_1.default)(contents);
    }
    /**
     * Makes cache path from a given file path and its contents
     */
    makeCachePath(filePath, contents, extname) {
        const relativeCachePath = (0, utils_1.getCachePathForFile)(this.appRoot, filePath);
        const hash = this.generateHash(contents);
        return (0, path_1.join)(this.cacheRoot, relativeCachePath, `${hash}${extname}`);
    }
    /**
     * Returns the file contents from the cache (if exists), otherwise
     * returns null
     */
    get(cachePath) {
        try {
            const contents = (0, fs_extra_1.readFileSync)(cachePath, 'utf8');
            (0, utils_1.debug)('reading from cache "%s"', cachePath);
            return contents;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                return null;
            }
            throw error;
        }
    }
    /**
     * Writes file contents to the disk
     */
    set(cachePath, contents) {
        (0, utils_1.debug)('writing to cache "%s"', cachePath);
        (0, fs_extra_1.outputFileSync)(cachePath, contents);
    }
    /**
     * Clears all the generate cache for a given file
     */
    clearForFile(filePath) {
        (0, utils_1.debug)('clear cache for "%s"', filePath);
        const relativeCachePath = (0, utils_1.getCachePathForFile)(this.appRoot, filePath);
        (0, fs_extra_1.removeSync)((0, path_1.join)(this.cacheRoot, relativeCachePath));
    }
    /**
     * Clears the cache root folder
     */
    clearAll() {
        (0, fs_extra_1.removeSync)(this.cacheRoot);
    }
}
exports.Cache = Cache;
/**
 * A parallel fake implementation of cache that results in noop. Used
 * when caching is disabled.
 */
class FakeCache {
    constructor() { }
    /**
     * Generates hash from file contents
     */
    generateHash(_) {
        return '';
    }
    /**
     * Makes cache path from a given file path and its contents
     */
    makeCachePath(_, __, ___) {
        return '';
    }
    /**
     * Returns the file contents from the cache (if exists), otherwise
     * returns null
     */
    get(_) {
        return null;
    }
    /**
     * Writes file contents to the disk
     */
    set(_, __) { }
    /**
     * Clears all the generate cache for a given file
     */
    clearForFile(_) { }
    /**
     * Clears the cache root folder
     */
    clearAll() { }
}
exports.FakeCache = FakeCache;
