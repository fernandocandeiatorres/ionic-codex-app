"use strict";
/*
 * @adonisjs/require-ts
 *
 * (c) Harminder Virk <virk@adonisjs.comharminder@cav.ai>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = exports.loadCompiler = exports.getWatcherHelpers = exports.symbols = void 0;
const pirates_1 = require("pirates");
const find_cache_dir_1 = __importDefault(require("find-cache-dir"));
const Cache_1 = require("./src/Cache");
const Config_1 = require("./src/Config");
const Compiler_1 = require("./src/Compiler");
const utils_1 = require("./src/utils");
/**
 * Extensions to register require extension for
 */
const EXTS = ['.ts', '.tsx'];
const CACHE_DIR_NAME = 'adonis-require-ts';
/**
 * Symbols that can be used to get the global reference of the compiler
 */
exports.symbols = {
    compiler: Symbol.for('REQUIRE_TS_COMPILER'),
    config: Symbol.for('REQUIRE_TS_CONFIG'),
};
/**
 * Returns helpers to along with cache when using a watcher.
 *
 * - You can check if the tsconfig file inside the cache is stale or not.
 * 	 If it is stale, then clear the entire cache
 *
 * - Clear cache for a given file path.
 * - Clear all cache
 */
function getWatcherHelpers(appRoot, cachePath) {
    cachePath = cachePath || (0, find_cache_dir_1.default)({ name: CACHE_DIR_NAME });
    const cache = new Cache_1.Cache(appRoot, cachePath);
    return {
        clear(filePath) {
            return filePath ? cache.clearForFile(filePath) : cache.clearAll();
        },
        isConfigStale: () => {
            const config = new Config_1.Config(appRoot, cachePath, undefined, true);
            const { cached } = config.getCached();
            return !cached || cached.version !== Config_1.Config.version;
        },
    };
}
exports.getWatcherHelpers = getWatcherHelpers;
/**
 * Load in-memory typescript compiler
 */
function loadCompiler(appRoot, options) {
    const typescript = (0, utils_1.loadTypescript)(appRoot);
    return new Compiler_1.Compiler(appRoot, appRoot, typescript, options, false);
}
exports.loadCompiler = loadCompiler;
/**
 * Register hook to compile typescript files in-memory. When
 * caching is enabled, the compiled files will be written
 * on the disk
 */
function register(appRoot, opts) {
    /**
     * Normalize options
     */
    opts = Object.assign({ cache: false, cachePath: '' }, opts);
    if (opts.cache && !opts.cachePath) {
        opts.cachePath = (0, find_cache_dir_1.default)({ name: CACHE_DIR_NAME });
    }
    const typescript = (0, utils_1.loadTypescript)(appRoot);
    /**
     * Parse config
     */
    const config = new Config_1.Config(appRoot, opts.cachePath, typescript, !!opts.cache).parse();
    /**
     * Cannot continue when config has errors
     */
    if (config.error) {
        process.exit(1);
    }
    /**
     * Merge transformers when defined
     */
    if (opts.transformers) {
        config.options.transformers = config.options.transformers || {};
        if (opts.transformers.before) {
            config.options.transformers.before = (config.options.transformers.before || []).concat(opts.transformers.before);
        }
        if (opts.transformers.after) {
            config.options.transformers.after = (config.options.transformers.after || []).concat(opts.transformers.after);
        }
        if (opts.transformers.afterDeclarations) {
            config.options.transformers.afterDeclarations = (config.options.transformers.afterDeclarations || []).concat(opts.transformers.afterDeclarations);
        }
    }
    /**
     * Instantiate compiler to compile `.ts` files using the typescript compiler. Currently
     * we not resolve `.js` files and will never resolve `.tsx` or `.jsx` files.
     */
    const compiler = new Compiler_1.Compiler(appRoot, opts.cachePath, typescript, config.options, !!opts.cache);
    global[exports.symbols.compiler] = compiler;
    global[exports.symbols.config] = config;
    (0, pirates_1.addHook)((code, filename) => {
        return compiler.compile(filename, code);
    }, { exts: EXTS, matcher: () => true });
}
exports.register = register;
