"use strict";
/*
 * @adonisjs/ioc-transformer
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.iocTransformer = void 0;
/**
 * Find if the node is a require call
 */
function isRequireCall(node, ts) {
    return (ts.isCallExpression(node) &&
        node.expression &&
        ts.isIdentifier(node.expression) &&
        node.expression.escapedText === 'require');
}
/**
 * Returns the module identifier. Performs checks for dynamic imports as well
 */
function getModuleIdentifier(node, ts) {
    const firstArg = node.arguments[0];
    let moduleIdentifier = null;
    let expressionType = 'unknown';
    if (ts.isTemplateExpression(firstArg)) {
        moduleIdentifier = firstArg.head.text;
        expressionType = 'templateLiteral';
    }
    else if (ts.isStringLiteral(firstArg)) {
        moduleIdentifier = firstArg.text;
        expressionType = 'static';
    }
    else if (ts.isBinaryExpression(firstArg) && ts.isStringLiteral(firstArg.left)) {
        moduleIdentifier = firstArg.left.text;
        expressionType = 'binary';
    }
    return { moduleIdentifier, expressionType };
}
/**
 * Find if the module indentifier is a container binding
 */
function isContainerBinding(moduleIdentifier) {
    return !!moduleIdentifier && moduleIdentifier.startsWith('@ioc:');
}
/**
 * Find if the module indentifier is an alias
 */
function isAlias(aliases, moduleIdentifier) {
    return !!(moduleIdentifier && aliases.find((alias) => moduleIdentifier.startsWith(`${alias}/`)));
}
/**
 * Converts Ioc container import statements to `use` statements
 * in compiled Javascript code.
 */
function iocTransformer(ts, rcFile) {
    const aliases = Object.keys(rcFile.aliases || {});
    return (ctx) => {
        return (sourceFile) => {
            function visitor(node) {
                if (isRequireCall(node, ts)) {
                    const { moduleIdentifier, expressionType } = getModuleIdentifier(node, ts);
                    if (isContainerBinding(moduleIdentifier)) {
                        if (expressionType !== 'static') {
                            throw new Error('Imports prefixed with "@ioc:" cannot use runtime values');
                        }
                        return ts.factory.createCallExpression(ts.factory.createIdentifier("global[Symbol.for('ioc.use')]"), undefined, [ts.factory.createStringLiteral(moduleIdentifier.substr(5))]);
                    }
                    if (isAlias(aliases, moduleIdentifier)) {
                        return ts.factory.createCallExpression(ts.factory.createIdentifier("global[Symbol.for('ioc.use')]"), undefined, node.arguments);
                    }
                }
                return ts.visitEachChild(node, visitor, ctx);
            }
            return ts.visitEachChild(sourceFile, visitor, ctx);
        };
    };
}
exports.iocTransformer = iocTransformer;
