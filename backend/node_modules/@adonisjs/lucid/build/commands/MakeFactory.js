"use strict";
/*
 * @adonisjs/assembler
 *
 * (c) AdonisJS
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const standalone_1 = require("@adonisjs/core/build/standalone");
/**
 * Command to make a new Factory
 */
class MakeFactory extends standalone_1.BaseCommand {
    constructor() {
        super(...arguments);
        /**
         * Name of the model to be used in the factory
         */
        Object.defineProperty(this, "model", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Import path to the model used in the factory
         */
        Object.defineProperty(this, "modelPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exact", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    /**
     * Generate model import path used in the factory
     */
    generateModelImportPath() {
        let base = this.application.rcFile.namespaces.models || 'App/Models';
        if (!base.endsWith('/')) {
            base += '/';
        }
        let importPath = this.model;
        if (this.modelPath) {
            importPath = this.modelPath;
        }
        else if (importPath.endsWith('Factory')) {
            importPath = importPath.replace(/Factory$/, '');
        }
        if (importPath.startsWith(base)) {
            return importPath;
        }
        return base + importPath;
    }
    /**
     * Path to the factories directory
     */
    getDestinationPath() {
        const base = this.application.rcFile.directories.database || 'database';
        return (0, path_1.join)(base, 'factories');
    }
    /**
     * Passed down to the stub template
     */
    templateData() {
        return {
            model: this.model,
            modelImportPath: this.generateModelImportPath(),
            toModelName: () => {
                return function (model, render) {
                    return render(model).split('/').pop();
                };
            },
        };
    }
    async run() {
        const stub = (0, path_1.join)(__dirname, '..', 'templates', 'factory.txt');
        this.generator
            .addFile(this.model, { pattern: 'pascalcase', form: 'singular', suffix: 'Factory' })
            .stub(stub)
            .useMustache()
            .destinationDir(this.getDestinationPath())
            .appRoot(this.application.appRoot)
            .apply(this.templateData());
        await this.generator.run();
    }
}
Object.defineProperty(MakeFactory, "commandName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'make:factory'
});
Object.defineProperty(MakeFactory, "description", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'Make a new factory'
});
__decorate([
    standalone_1.args.string({ description: 'The name of the model' }),
    __metadata("design:type", String)
], MakeFactory.prototype, "model", void 0);
__decorate([
    standalone_1.flags.string({ description: 'The path to the model' }),
    __metadata("design:type", String)
], MakeFactory.prototype, "modelPath", void 0);
__decorate([
    standalone_1.flags.boolean({
        description: 'Create the factory with the exact name as provided',
        alias: 'e',
    }),
    __metadata("design:type", Boolean)
], MakeFactory.prototype, "exact", void 0);
exports.default = MakeFactory;
