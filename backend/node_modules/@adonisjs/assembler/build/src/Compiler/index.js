"use strict";
/*
 * @adonisjs/assembler
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compiler = void 0;
const slash_1 = __importDefault(require("slash"));
const cpy_1 = __importDefault(require("cpy"));
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const ioc_transformer_1 = require("@adonisjs/ioc-transformer");
const cliui_1 = require("@poppinss/cliui");
const Ts_1 = require("../Ts");
const RcFile_1 = require("../RcFile");
const Manifest_1 = require("../Manifest");
const paths_1 = require("../../config/paths");
const AssetsBundler_1 = require("../AssetsBundler");
/**
 * Exposes the API to build the AdonisJs project for development or
 * production. The production build has it's own set of node_modules
 */
class Compiler {
    constructor(appRoot, encoreArgs, buildAssets, logger = cliui_1.logger, tsconfig) {
        this.appRoot = appRoot;
        this.encoreArgs = encoreArgs;
        this.buildAssets = buildAssets;
        this.logger = logger;
        /**
         * Reference to rc File
         */
        this.rcFile = new RcFile_1.RcFile(this.appRoot);
        this.ts = new Ts_1.Ts(this.appRoot, this.logger, tsconfig);
        this.ts.tsCompiler.use(() => {
            return (0, ioc_transformer_1.iocTransformer)(this.ts.tsCompiler.ts, this.rcFile.application.rcFile);
        }, 'after');
    }
    /**
     * Returns relative unix path from the project root. Used for
     * display only
     */
    getRelativeUnixPath(absPath) {
        return (0, slash_1.default)((0, path_1.relative)(this.appRoot, absPath));
    }
    /**
     * Cleans up the build directory
     */
    async cleanupBuildDirectory(outDir) {
        this.getRelativeUnixPath(outDir);
        this.logger.info(`cleaning up ${this.logger.colors
            .dim()
            .yellow(`"./${this.getRelativeUnixPath(outDir)}"`)} directory`);
        await (0, fs_extra_1.remove)(outDir);
    }
    /**
     * Copies .adonisrc.json file to the destination
     */
    async copyAdonisRcFile(outDir) {
        this.logger.info(`copy { ${this.logger.colors
            .dim()
            .yellow(`${paths_1.RCFILE_NAME} => ${this.getRelativeUnixPath(outDir)}`)} }`);
        await (0, fs_extra_1.outputJSON)((0, path_1.join)(outDir, paths_1.RCFILE_NAME), Object.assign({}, this.rcFile.getDiskContents(), {
            typescript: false,
            lastCompiledAt: new Date().toISOString(),
        }), { spaces: 2 });
    }
    /**
     * Copy all meta files to the build directory
     */
    async copyMetaFiles(outDir, extraFiles) {
        const metaFiles = this.rcFile.getMetaFilesGlob().concat(extraFiles || []);
        this.logger.info(`copy { ${this.logger.colors
            .dim()
            .yellow(`${metaFiles.join(',')} => ${this.getRelativeUnixPath(outDir)}`)} }`);
        await this.copyFiles(metaFiles, outDir);
    }
    /**
     * Copy files to destination directory
     */
    async copyFiles(files, outDir) {
        try {
            await (0, cpy_1.default)(files, outDir, { cwd: this.appRoot, parents: true });
        }
        catch (error) {
            if (!error.message.includes("the file doesn't exist")) {
                throw error;
            }
        }
    }
    /**
     * Build typescript source files
     */
    buildTypescriptSource(config) {
        this.logger.info('compiling typescript source files');
        const builder = this.ts.tsCompiler.builder(config);
        const { skipped, diagnostics } = builder.build();
        if (skipped) {
            this.logger.warning('typescript emit skipped');
        }
        if (diagnostics.length) {
            this.logger.error('typescript compiler errors');
            this.ts.renderDiagnostics(diagnostics, builder.host);
        }
        return {
            skipped,
            hasErrors: diagnostics.length > 0,
        };
    }
    /**
     * Log the message that ts build and failed
     */
    logTsBuildFailed() {
        this.logger.logError('');
        this.logger.logError(this.logger.colors.bgRed(`Cannot complete the build process as there are typescript errors. Use "--ignore-ts-errors" flag to ignore Typescript errors`));
    }
    /**
     * Typecheck the project without emit
     */
    async typeCheck() {
        const config = this.ts.parseConfig();
        if (!config) {
            return false;
        }
        this.logger.info('type checking typescript source files');
        config.options.noEmit = true;
        const builder = this.ts.tsCompiler.builder(config);
        const { diagnostics } = builder.build();
        if (diagnostics.length) {
            this.logger.error('typescript compiler errors');
            this.ts.renderDiagnostics(diagnostics, builder.host);
            return false;
        }
        this.logger.success('built successfully');
        return true;
    }
    /**
     * Compile project. See [[Compiler.compileForProduction]] for
     * production build
     */
    async compile(stopOnError = true, extraFiles) {
        const config = this.ts.parseConfig();
        if (!config) {
            return false;
        }
        /**
         * Bundle frontend assets when encore is installed
         */
        const encore = await new AssetsBundler_1.AssetsBundler(this.appRoot, this.encoreArgs, this.buildAssets, this.logger).build();
        /**
         * Skipped, coz of frontend errors
         */
        if (encore.hasErrors) {
            return false;
        }
        /**
         * Always cleanup the out directory
         */
        await this.cleanupBuildDirectory(config.options.outDir);
        /**
         * Build typescript source
         */
        const ts = this.buildTypescriptSource(config);
        /**
         * Do not continue when output was skipped
         */
        if (ts.skipped) {
            return false;
        }
        /**
         * Do not continue when has errors and "stopOnError" is true
         */
        if (stopOnError && ts.hasErrors) {
            this.logTsBuildFailed();
            await this.cleanupBuildDirectory(config.options.outDir);
            return false;
        }
        /**
         * Begin by copying meta files
         */
        await this.copyMetaFiles(config.options.outDir, extraFiles);
        /**
         * Copy `.adonisrc.json` file
         */
        await this.copyAdonisRcFile(config.options.outDir);
        /**
         * Manifest instance to generate ace manifest file
         */
        const manifest = new Manifest_1.Manifest(config.options.outDir, this.logger);
        const created = await manifest.generate();
        /**
         * Do not continue when unable to generate the manifest file as commands
         * won't be available
         */
        if (!created) {
            await this.cleanupBuildDirectory(config.options.outDir);
            return false;
        }
        this.logger.success('built successfully');
        return true;
    }
    /**
     * Compile project. See [[Compiler.compile]] for development build
     */
    async compileForProduction(stopOnError = true, client) {
        const config = this.ts.parseConfig();
        if (!config) {
            return false;
        }
        /**
         * Bundle frontend assets when encore is installed
         */
        const encore = await new AssetsBundler_1.AssetsBundler(this.appRoot, this.encoreArgs, this.buildAssets, this.logger).buildForProduction();
        /**
         * Skipped, coz of frontend errors
         */
        if (encore.hasErrors) {
            return false;
        }
        const pkgFiles = client === 'npm' ? ['package.json', 'package-lock.json'] : ['package.json', 'yarn.lock'];
        /**
         * Always cleanup the out directory
         */
        await this.cleanupBuildDirectory(config.options.outDir);
        /**
         * Build typescript source
         */
        const { skipped, hasErrors } = this.buildTypescriptSource(config);
        /**
         * Do not continue when output was skipped
         */
        if (skipped) {
            return false;
        }
        /**
         * Do not continue when has errors and "stopOnError" is true and cleanup
         * the build directory
         */
        if (stopOnError && hasErrors) {
            this.logTsBuildFailed();
            await this.cleanupBuildDirectory(config.options.outDir);
            return false;
        }
        /**
         * Begin by copying meta files
         */
        await this.copyMetaFiles(config.options.outDir, pkgFiles);
        /**
         * Copy `.adonisrc.json` file
         */
        await this.copyAdonisRcFile(config.options.outDir);
        /**
         * Generate commands manifest
         */
        const manifest = new Manifest_1.Manifest(config.options.outDir, this.logger);
        const created = await manifest.generate();
        /**
         * Do not continue when unable to generate the manifest file as commands
         * won't be available
         */
        if (!created) {
            await this.cleanupBuildDirectory(config.options.outDir);
            return false;
        }
        /**
         * Print usage instructions
         */
        const installCommand = client === 'npm' ? 'npm ci --production' : 'yarn install --production';
        const relativeBuildPath = this.getRelativeUnixPath(config.options.outDir);
        this.logger.success('built successfully');
        this.logger.log('');
        (0, cliui_1.instructions)()
            .heading('Run the following commands to start the server in production')
            .add(this.logger.colors.cyan(`cd ${relativeBuildPath}`))
            .add(this.logger.colors.cyan(installCommand))
            .add(this.logger.colors.cyan('node server.js'))
            .render();
        return true;
    }
}
exports.Compiler = Compiler;
