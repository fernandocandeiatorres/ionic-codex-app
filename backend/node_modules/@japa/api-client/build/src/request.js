"use strict";
/*
 * @japa/api-client
 *
 * (c) Japa.dev
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiRequest = void 0;
const cookie_1 = __importDefault(require("cookie"));
const macroable_1 = require("macroable");
const hooks_1 = require("@poppinss/hooks");
const superagent_1 = __importDefault(require("superagent"));
const response_1 = require("./response");
const utils_1 = require("./utils");
const DUMP_CALLS = {
    request: utils_1.dumpRequest,
    body: utils_1.dumpRequestBody,
    cookies: utils_1.dumpRequestCookies,
    headers: utils_1.dumpRequestHeaders,
};
class ApiRequest extends macroable_1.Macroable {
    constructor(config, assert) {
        super();
        this.config = config;
        this.assert = assert;
        /**
         * Reference to registered hooks
         */
        this.hooks = new hooks_1.Hooks();
        /**
         * Dump calls
         */
        this.valuesToDump = new Set();
        /**
         * The underlying super agent request
         */
        this.request = this.createRequest();
        /**
         * Cookies to be sent with the request
         */
        this.cookiesJar = {};
        this.config.hooks?.setup.forEach((handler) => this.setup(handler));
        this.config.hooks?.teardown.forEach((handler) => this.teardown(handler));
    }
    /**
     * Set cookies header
     */
    setCookiesHeader() {
        const prepareMethod = this.config.serializers?.cookie?.prepare;
        const cookies = Object.keys(this.cookiesJar).map((key) => {
            let { name, value } = this.cookiesJar[key];
            if (prepareMethod) {
                value = prepareMethod(name, value, this);
            }
            return cookie_1.default.serialize(name, value);
        });
        if (!cookies.length) {
            return;
        }
        this.header('Cookie', cookies);
    }
    /**
     * Instantiate hooks runner
     */
    instantiateHooksRunners() {
        this.setupRunner = this.hooks.runner('setup');
        this.teardownRunner = this.hooks.runner('teardown');
    }
    /**
     * Run setup hooks
     */
    async runSetupHooks() {
        try {
            await this.setupRunner.run(this);
        }
        catch (error) {
            await this.setupRunner.cleanup(error, this);
            throw error;
        }
    }
    /**
     * Run teardown hooks
     */
    async runTeardownHooks(response) {
        try {
            await this.teardownRunner.run(response);
        }
        catch (error) {
            await this.teardownRunner.cleanup(error, response);
            throw error;
        }
        await this.teardownRunner.cleanup(null, response);
    }
    /**
     * Send HTTP request to the server. Errors except the client errors
     * are tured into a response object.
     */
    async sendRequest() {
        let response;
        try {
            this.setCookiesHeader();
            this.dumpValues();
            response = await this.request.buffer(true);
        }
        catch (error) {
            this.request.abort();
            /**
             * Call cleanup hooks
             */
            if (!error.response) {
                await this.setupRunner.cleanup(error, this);
                throw error;
            }
            /**
             * Raise exception when received 500 status code from the server
             */
            if (error.response.status >= 500) {
                await this.setupRunner.cleanup(error, this);
                throw (0, utils_1.stackToError)(error.response.text);
            }
            response = error.response;
        }
        await this.setupRunner.cleanup(null, this);
        return new response_1.ApiResponse(this, response, this.config, this.assert);
    }
    /**
     * Invoke calls calls
     */
    dumpValues() {
        if (!this.valuesToDump.size) {
            return;
        }
        try {
            this.valuesToDump.forEach((key) => {
                DUMP_CALLS[key](this);
            });
        }
        catch (error) {
            console.log(error);
        }
    }
    /**
     * Is endpoint a fully qualified URL or not
     */
    isUrl(url) {
        return url.startsWith('http://') || url.startsWith('https://');
    }
    /**
     * Prepend baseUrl to the endpoint
     */
    prependBaseUrl(url) {
        if (!this.config.baseUrl) {
            return url;
        }
        return `${this.config.baseUrl}/${url.replace(/^\//, '')}`;
    }
    /**
     * Creates the request instance for the given HTTP method
     */
    createRequest() {
        let url = this.config.endpoint;
        if (!this.isUrl(url)) {
            url = this.prependBaseUrl(url);
        }
        return (0, superagent_1.default)(this.config.method, url);
    }
    /**
     * Register a setup hook. Setup hooks are called before
     * making the request
     */
    setup(handler) {
        this.hooks.add('setup', handler);
        return this;
    }
    /**
     * Register a teardown hook. Teardown hooks are called after
     * making the request
     */
    teardown(handler) {
        this.hooks.add('teardown', handler);
        return this;
    }
    /**
     * Set cookie as a key-value pair to be sent to the server
     */
    cookie(key, value) {
        this.cookiesJar[key] = { name: key, value };
        return this;
    }
    /**
     * Set cookies as an object to be sent to the server
     */
    cookies(cookies) {
        Object.keys(cookies).forEach((key) => this.cookie(key, cookies[key]));
        return this;
    }
    /**
     * Define request header as a key-value pair.
     *
     * @example
     * request.header('x-foo', 'bar')
     * request.header('x-foo', ['bar', 'baz'])
     */
    header(key, value) {
        this.headers({ [key]: value });
        return this;
    }
    /**
     * Define request headers as an object.
     *
     * @example
     * request.headers({ 'x-foo': 'bar' })
     * request.headers({ 'x-foo': ['bar', 'baz'] })
     */
    headers(headers) {
        this.request.set(headers);
        return this;
    }
    /**
     * Define the field value for a multipart request.
     *
     * @note: This method makes a multipart request. See [[this.form]] to
     * make HTML style form submissions.
     *
     * @example
     * request.field('name', 'virk')
     * request.field('age', 22)
     */
    field(name, value) {
        this.request.field(name, value);
        return this;
    }
    /**
     * Define fields as an object for a multipart request
     *
     * @note: This method makes a multipart request. See [[this.form]] to
     * make HTML style form submissions.
     *
     * @example
     * request.fields({'name': 'virk', age: 22})
     */
    fields(values) {
        this.request.field(values);
        return this;
    }
    /**
     * Upload file for a multipart request. Either you can pass path to a
     * file, a readable stream, or a buffer
     *
     * @example
     * request.file('avatar', 'absolute/path/to/file')
     * request.file('avatar', createReadStream('./path/to/file'))
     */
    file(name, value, options) {
        this.request.attach(name, value, options);
        return this;
    }
    /**
     * Set form values. Calling this method will set the content type
     * to "application/x-www-form-urlencoded".
     *
     * @example
     * request.form({
     *   email: 'virk@adonisjs.com',
     *   password: 'secret'
     * })
     */
    form(values) {
        this.type('form');
        this.request.send(values);
        return this;
    }
    /**
     * Set JSON body for the request. Calling this method will set
     * the content type to "application/json".
     *
     * @example
     * request.json({
     *   email: 'virk@adonisjs.com',
     *   password: 'secret'
     * })
     */
    json(values) {
        this.type('json');
        this.request.send(values);
        return this;
    }
    qs(key, value) {
        if (!value) {
            this.request.query(key);
        }
        else {
            this.request.query({ [key]: value });
        }
        return this;
    }
    /**
     * Set timeout for the request.
     *
     * @example
     * request.timeout(5000)
     * request.timeout({ response: 5000, deadline: 60000 })
     */
    timeout(ms) {
        this.request.timeout(ms);
        return this;
    }
    /**
     * Set content-type for the request
     *
     * @example
     * request.type('json')
     */
    type(value) {
        this.request.type(value);
        return this;
    }
    /**
     * Set "accept" header in the request
     *
     * @example
     * request.accept('json')
     */
    accept(type) {
        this.request.accept(type);
        return this;
    }
    /**
     * Follow redirects from the response
     *
     * @example
     * request.redirects(3)
     */
    redirects(count) {
        this.request.redirects(count);
        return this;
    }
    /**
     * Set basic auth header from user and password
     *
     * @example
     * request.basicAuth('foo@bar.com', 'secret')
     */
    basicAuth(user, password) {
        this.request.auth(user, password, { type: 'basic' });
        return this;
    }
    /**
     * Pass auth bearer token as authorization header.
     *
     * @example
     * request.apiToken('tokenValue')
     */
    bearerToken(token) {
        this.request.auth(token, { type: 'bearer' });
        return this;
    }
    /**
     * Set the ca certificates to trust
     */
    ca(certificate) {
        this.request.ca(certificate);
        return this;
    }
    /**
     * Set the client certificates
     */
    cert(certificate) {
        this.request.cert(certificate);
        return this;
    }
    /**
     * Set the client private key(s)
     */
    privateKey(key) {
        this.request.key(key);
        return this;
    }
    /**
     * Set the client PFX or PKCS12 encoded private key and certificate chain
     */
    pfx(key) {
        this.request.pfx(key);
        return this;
    }
    /**
     * Does not reject expired or invalid TLS certs. Sets internally rejectUnauthorized=true
     */
    disableTLSCerts() {
        this.request.disableTLSCerts();
        return this;
    }
    /**
     * Trust broken HTTPs connections on localhost
     */
    trustLocalhost(trust = true) {
        this.request.trustLocalhost(trust);
        return this;
    }
    /**
     * Dump request headers
     */
    dumpHeaders() {
        this.valuesToDump.add('headers');
        return this;
    }
    /**
     * Dump request cookies
     */
    dumpCookies() {
        this.valuesToDump.add('cookies');
        return this;
    }
    /**
     * Dump request body
     */
    dumpBody() {
        this.valuesToDump.add('body');
        return this;
    }
    /**
     * Dump request
     */
    dump() {
        this.valuesToDump.add('request');
        this.dumpCookies();
        this.dumpHeaders();
        this.dumpBody();
        return this;
    }
    /**
     * Retry a failing request. Along with the count, you can also define
     * a callback to decide how long the request should be retried.
     *
     * The max count is applied regardless of whether callback is defined
     * or not
     *
     * The following response codes are considered failing.
     * - 408
     * - 413
     * - 429
     * - 500
     * - 502
     * - 503
     * - 504
     * - 521
     * - 522
     * - 524
     *
     * The following error codes are considered failing.
     * - 'ETIMEDOUT'
     * - 'ECONNRESET'
     * - 'EADDRINUSE'
     * - 'ECONNREFUSED'
     * - 'EPIPE'
     * - 'ENOTFOUND'
     * - 'ENETUNREACH'
     * - 'EAI_AGAIN'
     */
    retry(count, retryUntilCallback) {
        if (retryUntilCallback) {
            this.request.retry(count, (error, response) => {
                return retryUntilCallback(error, new response_1.ApiResponse(this, response, this.config, this.assert));
            });
            return this;
        }
        this.request.retry(count);
        return this;
    }
    /**
     * Make the API request
     */
    async send() {
        /**
         * Step 1: Instantiate hooks runners
         */
        this.instantiateHooksRunners();
        /**
         * Step 2: Run setup hooks
         */
        await this.runSetupHooks();
        /**
         * Step 3: Make HTTP request
         */
        const response = await this.sendRequest();
        /**
         * Step 4: Run teardown hooks
         */
        await this.runTeardownHooks(response);
        return response;
    }
    /**
     * Implementation of `then` for the promise API
     */
    then(resolve, reject) {
        return this.send().then(resolve, reject);
    }
    /**
     * Implementation of `catch` for the promise API
     */
    catch(reject) {
        return this.send().catch(reject);
    }
    /**
     * Implementation of `finally` for the promise API
     */
    finally(fullfilled) {
        return this.send().finally(fullfilled);
    }
    /**
     * Required when Promises are extended
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
}
exports.ApiRequest = ApiRequest;
/**
 * Properties required by the Macroable class
 */
ApiRequest.macros = {};
ApiRequest.getters = {};
/**
 * Register/remove custom superagent parser
 */
ApiRequest.addParser = (contentType, parser) => {
    superagent_1.default.parse[contentType] = parser;
};
ApiRequest.removeParser = (contentType) => {
    delete superagent_1.default.parse[contentType];
};
/**
 * Register/remove custom superagent serializers
 */
ApiRequest.addSerializer = (contentType, serializer) => {
    superagent_1.default.serialize[contentType] = serializer;
};
ApiRequest.removeSerializer = (contentType) => {
    delete superagent_1.default.serialize[contentType];
};
