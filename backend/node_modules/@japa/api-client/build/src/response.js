"use strict";
/*
 * @japa/api-client
 *
 * (c) Japa.dev
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiResponse = void 0;
const macroable_1 = require("macroable");
const set_cookie_parser_1 = __importDefault(require("set-cookie-parser"));
const utils_1 = require("./utils");
class ApiResponse extends macroable_1.Macroable {
    constructor(request, response, config, assert) {
        super();
        this.request = request;
        this.response = response;
        this.config = config;
        this.assert = assert;
        this.valuesDumped = new Set();
        /**
         * Parsed cookies
         */
        this.cookiesJar = this.parseCookies();
        this.processCookies();
    }
    /**
     * Parse response header to collect cookies
     */
    parseCookies() {
        const cookieHeader = this.header('set-cookie');
        if (!cookieHeader) {
            return {};
        }
        return set_cookie_parser_1.default.parse(cookieHeader, { map: true });
    }
    /**
     * Process cookies using the serializer
     */
    processCookies() {
        const cookiesSerializer = this.config.serializers?.cookie;
        const processMethod = cookiesSerializer?.process;
        if (!processMethod) {
            return;
        }
        Object.keys(this.cookiesJar).forEach((key) => {
            const cookie = this.cookiesJar[key];
            const processedValue = processMethod(cookie.name, cookie.value, this);
            if (processedValue !== undefined) {
                cookie.value = processedValue;
            }
        });
    }
    /**
     * Ensure assert plugin is installed
     */
    ensureHasAssert() {
        if (!this.assert) {
            throw new Error('Response assertions are not available. Make sure to install the @japa/assert plugin');
        }
    }
    /**
     * Response content-type charset. Undefined if no charset
     * is mentioned.
     */
    charset() {
        return this.response.charset;
    }
    /**
     * Parsed files from the multipart response.
     */
    files() {
        return this.response.files;
    }
    /**
     * Returns an object of links by parsing the "Link" header.
     *
     * @example
     * Link: <https://one.example.com>; rel="preconnect", <https://two.example.com>; rel="preload"
     * response.links()
     * // {
     * //   preconnect: 'https://one.example.com',
       //   preload: 'https://two.example.com',
     * // }
     */
    links() {
        return this.response.links;
    }
    /**
     * Response status type
     */
    statusType() {
        return this.response.statusType;
    }
    /**
     * Request raw parsed text
     */
    text() {
        return this.response.text;
    }
    /**
     * Response body
     */
    body() {
        return this.response.body;
    }
    /**
     * Read value for a given response header
     */
    header(key) {
        return this.response.headers[key];
    }
    /**
     * Get all response headers
     */
    headers() {
        return this.response.headers;
    }
    /**
     * Get response status
     */
    status() {
        return this.response.status;
    }
    /**
     * Get response content-type
     */
    type() {
        return this.response.type;
    }
    /**
     * Get redirects URLs the request has followed before
     * getting the response
     */
    redirects() {
        return this.response.redirects;
    }
    /**
     * Find if the response has parsed body. The check is performed
     * by inspecting the response content-type and returns true
     * when content-type is either one of the following.
     *
     * - application/json
     * - application/x-www-form-urlencoded
     * - multipart/form-data
     *
     * Or when the response body is a buffer.
     */
    hasBody() {
        return (this.type() === 'application/json' ||
            this.type() === 'application/x-www-form-urlencoded' ||
            this.type() === 'multipart/form-data' ||
            Buffer.isBuffer(this.response.body));
    }
    /**
     * Find if the response body has files
     */
    hasFiles() {
        return this.files() && Object.keys(this.files()).length > 0;
    }
    /**
     * Find if response is an error
     */
    hasError() {
        return this.error() ? true : false;
    }
    /**
     * Find if response is an fatal error. Response with >=500
     * status code are concerned as fatal errors
     */
    hasFatalError() {
        return this.status() >= 500;
    }
    /**
     * Find if the request client failed to make the request
     */
    hasClientError() {
        return this.response.clientError;
    }
    /**
     * Find if the server responded with an error
     */
    hasServerError() {
        return this.response.serverError;
    }
    /**
     * Access to response error
     */
    error() {
        return this.response.error;
    }
    /**
     * Get cookie by name
     */
    cookie(name) {
        return this.cookiesJar[name];
    }
    /**
     * Parsed response cookies
     */
    cookies() {
        return this.cookiesJar;
    }
    /**
     * Dump request headers
     */
    dumpHeaders() {
        if (this.valuesDumped.has('headers')) {
            return this;
        }
        this.valuesDumped.add('headers');
        (0, utils_1.dumpResponseHeaders)(this);
        return this;
    }
    /**
     * Dump request cookies
     */
    dumpCookies() {
        if (this.valuesDumped.has('cookies')) {
            return this;
        }
        this.valuesDumped.add('cookies');
        (0, utils_1.dumpResponseCookies)(this);
        return this;
    }
    /**
     * Dump request body
     */
    dumpBody() {
        if (this.valuesDumped.has('body')) {
            return this;
        }
        this.valuesDumped.add('body');
        (0, utils_1.dumpResponseBody)(this);
        return this;
    }
    /**
     * Dump request body
     */
    dumpError() {
        if (this.valuesDumped.has('error')) {
            return this;
        }
        this.valuesDumped.add('error');
        (0, utils_1.dumpResponseError)(this);
        return this;
    }
    /**
     * Dump request
     */
    dump() {
        if (this.valuesDumped.has('response')) {
            return this;
        }
        this.valuesDumped.add('response');
        (0, utils_1.dumpResponse)(this);
        this.dumpCookies();
        this.dumpHeaders();
        this.dumpBody();
        this.dumpError();
        return this;
    }
    /**
     * Assert response status to match the expected status
     */
    assertStatus(expectedStatus) {
        this.ensureHasAssert();
        this.assert.equal(this.status(), expectedStatus);
    }
    /**
     * Assert response body to match the expected body
     */
    assertBody(expectedBody) {
        this.ensureHasAssert();
        this.assert.deepEqual(this.body(), expectedBody);
    }
    /**
     * Assert response body to match the subset from the
     * expected body
     */
    assertBodyContains(expectedBody) {
        this.ensureHasAssert();
        this.assert.containsSubset(this.body(), expectedBody);
    }
    /**
     * Assert response to contain a given cookie and optionally
     * has the expected value
     */
    assertCookie(name, value) {
        this.ensureHasAssert();
        this.assert.property(this.cookies(), name);
        if (value !== undefined) {
            this.assert.deepEqual(this.cookie(name).value, value);
        }
    }
    /**
     * Assert response to not contain a given cookie
     */
    assertCookieMissing(name) {
        this.ensureHasAssert();
        this.assert.notProperty(this.cookies(), name);
    }
    /**
     * Assert response to contain a given header and optionally
     * has the expected value
     */
    assertHeader(name, value) {
        this.ensureHasAssert();
        this.assert.property(this.headers(), name);
        if (value !== undefined) {
            this.assert.deepEqual(this.header(name), value);
        }
    }
    /**
     * Assert response to not contain a given header
     */
    assertHeaderMissing(name) {
        this.ensureHasAssert();
        this.assert.notProperty(this.headers(), name);
    }
    /**
     * Assert response text to include the expected value
     */
    assertTextIncludes(expectedSubset) {
        this.ensureHasAssert();
        this.assert.include(this.text(), expectedSubset);
    }
    /**
     * Assert response body is valid as per the API spec.
     */
    assertAgainstApiSpec() {
        this.ensureHasAssert();
        this.assert.isValidApiResponse(this.response);
    }
    /**
     * Assert there is a matching redirect
     */
    assertRedirectsTo(pathname) {
        this.ensureHasAssert();
        const redirects = this.redirects().map((url) => new URL(url).pathname);
        this.assert.evaluate(redirects.find((one) => one === pathname), `Expected #{exp} to be one of #{act}`, {
            expected: [pathname],
            actual: redirects,
            operator: 'includes',
        });
    }
}
exports.ApiResponse = ApiResponse;
ApiResponse.macros = {};
ApiResponse.getters = {};
