"use strict";
/*
 * @poppinss/chokidar-ts
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Watcher = void 0;
const debug_1 = __importDefault(require("debug"));
const path_1 = require("path");
const chokidar_1 = __importDefault(require("chokidar"));
const emittery_1 = __importDefault(require("emittery"));
const Builder_1 = require("./Builder");
const SourceFilesManager_1 = require("./SourceFilesManager");
const debug = (0, debug_1.default)('tsc:watcher');
/**
 * Exposes the API to build the typescript project and then watch it
 * for changes.
 */
class Watcher extends emittery_1.default {
    constructor(cwd, ts, config, pluginManager) {
        super();
        this.cwd = cwd;
        this.ts = ts;
        this.config = config;
        this.pluginManager = pluginManager;
        debug('initiating watcher');
    }
    /**
     * Returns a boolean telling if it is a script file or not.
     *
     * We check for the `compilerOptions.allowJs` before marking
     * `.js` files as a script files.
     */
    isScriptFile(filePath) {
        if (filePath.endsWith('.ts') || filePath.endsWith('.tsx')) {
            return true;
        }
        if (this.compilerOptions.allowJs && filePath.endsWith('.js')) {
            return true;
        }
        return false;
    }
    /**
     * Initiates the source file manager to track the source files as they
     * are added, changed and removed
     */
    initiateSourceFileManager(config) {
        this.sourceFilesManager = new SourceFilesManager_1.SourceFilesManager(this.cwd, {
            includes: config.raw.include,
            excludes: config.raw.exclude,
            files: config.fileNames,
        });
    }
    /**
     * Initiates chokidar watcher
     */
    initiateWatcher(watchPattern = ['.'], watcherOptions) {
        watcherOptions = Object.assign({
            ignored: this.config.raw.exclude,
            cwd: this.cwd,
            ignoreInitial: true,
        }, watcherOptions);
        debug('initating watcher with %j options', watcherOptions);
        this.chokidar = chokidar_1.default.watch(watchPattern, watcherOptions);
    }
    /**
     * Process the source file
     */
    async processSourceFile(absPath, relativePath, trigger) {
        /**
         * Update the source files manager to add the new file or
         * bump it's version.
         *
         * Bumping the version is important, so that the typescript compiler
         * referencing the source files manager should re-read the file
         * from disk
         */
        if (trigger === 'add') {
            this.sourceFilesManager.add(absPath);
            this.emit('source:add', { relativePath, absPath });
        }
        else {
            this.sourceFilesManager.bumpVersion(absPath);
            this.emit('source:change', { relativePath, absPath });
        }
    }
    /**
     * Invoked when chokidar notifies for a new file addtion
     */
    onNewFile(filePath) {
        const absPath = (0, path_1.join)(this.cwd, filePath);
        if (!this.isScriptFile(filePath) || !this.sourceFilesManager.isSourceFile(absPath)) {
            debug('new file added "%s"', filePath);
            this.emit('add', { relativePath: filePath, absPath });
            return;
        }
        debug('new source file added "%s"', filePath);
        this.processSourceFile(absPath, filePath, 'add');
    }
    /**
     * Invoked when chokidar notifies for changes the existing
     * source file
     */
    onChange(filePath) {
        const absPath = (0, path_1.join)(this.cwd, filePath);
        if (!this.isScriptFile(filePath) || !this.sourceFilesManager.isSourceFile(absPath)) {
            debug('file changed "%s"', filePath);
            this.emit('change', { relativePath: filePath, absPath });
            return;
        }
        debug('source file changed "%s"', filePath);
        this.processSourceFile(absPath, filePath, 'change');
    }
    /**
     * Invoked when chokidar notifies for file deletion
     */
    onRemove(filePath) {
        const absPath = (0, path_1.join)(this.cwd, filePath);
        if (!this.isScriptFile(filePath) || !this.sourceFilesManager.isSourceFile(absPath)) {
            debug('file removed "%s"', filePath);
            this.emit('unlink', { relativePath: filePath, absPath });
            return;
        }
        debug('source file removed "%s"', filePath);
        /**
         * Clean up tracking for a given file
         */
        this.sourceFilesManager.remove(absPath);
        /**
         * Notify subscribers
         */
        this.emit('source:unlink', { relativePath: filePath, absPath });
    }
    /**
     * Build and watch project for changes
     */
    watch(watchPattern = ['.'], watcherOptions) {
        const builder = new Builder_1.Builder(this.ts, this.config, this.pluginManager);
        builder.createProgram();
        this.host = builder.host;
        this.program = builder.program;
        this.compilerOptions = builder.compilerOptions;
        this.initiateSourceFileManager(this.config);
        this.initiateWatcher(watchPattern, watcherOptions);
        this.chokidar.on('ready', () => {
            debug('watcher ready');
            this.emit('watcher:ready');
        });
        this.chokidar.on('add', (path) => this.onNewFile(path));
        this.chokidar.on('change', (path) => this.onChange(path));
        this.chokidar.on('unlink', (path) => this.onRemove(path));
    }
}
exports.Watcher = Watcher;
