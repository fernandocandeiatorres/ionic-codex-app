"use strict";
/*
 * @poppinss/chokidar-ts
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LspWatcher = void 0;
const debug_1 = __importDefault(require("debug"));
const path_1 = require("path");
const chokidar_1 = __importDefault(require("chokidar"));
const emittery_1 = __importDefault(require("emittery"));
const fs_extra_1 = require("fs-extra");
const Builder_1 = require("./Builder");
const ReferenceTree_1 = require("./ReferenceTree");
const ModuleResolver_1 = require("./ModuleResolver");
const DiagnosticsStore_1 = require("./DiagnosticsStore");
const SourceFilesManager_1 = require("./SourceFilesManager");
const debug = (0, debug_1.default)('tsc:watcher');
/**
 * Exposes the API to build the typescript project and then watch it
 * for changes.
 */
class LspWatcher extends emittery_1.default {
    constructor(cwd, ts, config, pluginManager) {
        super();
        this.cwd = cwd;
        this.ts = ts;
        this.config = config;
        this.pluginManager = pluginManager;
        debug('initiating watcher');
    }
    /**
     * Returns a boolean telling if it is a script file or not.
     *
     * We check for the `compilerOptions.allowJs` before marking
     * `.js` files as a script files.
     */
    isScriptFile(filePath) {
        if (filePath.endsWith('.ts') || filePath.endsWith('.tsx')) {
            return true;
        }
        if (this.compilerOptions.allowJs && filePath.endsWith('.js')) {
            return true;
        }
        return false;
    }
    /**
     * Returns resolved imports from the source text
     */
    getSourceImports(filePath, fileText) {
        const { importedFiles, ambientExternalModules } = this.ts.preProcessFile(fileText, true, true);
        if (ambientExternalModules) {
            this.moduleResolver.addAmbientModules(filePath, ambientExternalModules);
        }
        return importedFiles.reduce((result, { fileName }) => {
            const resolvedImport = this.moduleResolver.resolve(fileName, filePath);
            if (resolvedImport) {
                result.push(resolvedImport);
            }
            return result;
        }, []);
    }
    /**
     * Initiates the source file manager to track the source files as they
     * are added, changed and removed
     */
    initiateSourceFileManager(config) {
        this.sourceFilesManager = new SourceFilesManager_1.SourceFilesManager(this.cwd, {
            includes: config.raw.include,
            excludes: config.raw.exclude,
            files: config.fileNames,
        });
    }
    /**
     * Initiates the diagnostic store to store diagnostic messages
     */
    initiateDiagnosticsStore(diagnostics) {
        this.diagnosticsStore = new DiagnosticsStore_1.DiagnosticsStore();
        this.diagnosticsStore.bulkAdd(diagnostics);
    }
    /**
     * Initiates the module resolver. We need it to resolve imports
     */
    initiateModuleResolver() {
        this.moduleResolver = new ModuleResolver_1.ModuleResolver(this.ts, this.compilerOptions);
    }
    /**
     * Initiates the reference tree to track module dependencies
     */
    initiateReferenceTree() {
        this.referenceTree = new ReferenceTree_1.ReferenceTree();
        Object.keys(this.sourceFilesManager.toJSON()).forEach((filePath) => {
            const sourceFile = this.program.getSourceFile(filePath);
            if (!sourceFile) {
                return;
            }
            this.referenceTree.add(filePath, this.getSourceImports(filePath, sourceFile.text));
        });
    }
    /**
     * Initiates chokidar watcher
     */
    initiateWatcher(watchPattern = ['.'], watcherOptions) {
        watcherOptions = Object.assign({
            ignored: [this.config.raw.exclude],
            cwd: this.cwd,
            ignoreInitial: true,
        }, watcherOptions);
        debug('initating watcher with %j options', watcherOptions);
        this.chokidar = chokidar_1.default.watch(watchPattern, watcherOptions);
    }
    /**
     * Initiates the language service. We can use the service instance to
     * re-compile files, without re-building the entire project
     */
    initiateLanguageService(options) {
        /**
         * Compiler host for the language service. This is pretty much a copy/paste
         * from the Typescript compiler API documentation
         */
        const languageServiceHost = {
            readFile: this.ts.sys.readFile,
            fileExists: this.ts.sys.fileExists,
            readDirectory: this.ts.sys.readDirectory,
            getCurrentDirectory: () => this.cwd,
            getCompilationSettings: () => options,
            getScriptFileNames: () => Object.keys(this.sourceFilesManager.toJSON()),
            getDefaultLibFileName: (libOptions) => this.ts.getDefaultLibFilePath(libOptions),
            getCustomTransformers: () => this.pluginManager.getTransformers(this.ts, options),
            getScriptVersion: (file) => {
                const version = this.sourceFilesManager.getFileVersion(file);
                return version ? String(version) : '';
            },
            getScriptSnapshot: (fileName) => {
                const contents = this.ts.sys.readFile(fileName);
                if (contents === undefined) {
                    return undefined;
                }
                return this.ts.ScriptSnapshot.fromString(contents.toString());
            },
        };
        debug('initating language service');
        this.languageService = this.ts.createLanguageService(languageServiceHost, this.ts.createDocumentRegistry());
    }
    /**
     * Process the diagnostics for a given file by adding
     * them to the diagnostics store.
     */
    processFileDiagnostics(absPath) {
        const diagnostics = this.languageService
            .getCompilerOptionsDiagnostics()
            .concat(this.languageService.getSyntacticDiagnostics(absPath))
            .concat(this.languageService.getSemanticDiagnostics(absPath));
        this.diagnosticsStore.add(absPath, diagnostics);
    }
    /**
     * Rebuilds the source file without writing it's compiled output
     * to the disk. Following operations are peformed.
     *
     * 1. File is re-compiled
     * 2. File diagnostics are updated in the store.
     * 3. Reference tree is updated with new imports.
     */
    reBuildSourceFile(absPath) {
        /**
         * Process file diagnostics and update the diagnostic store
         */
        this.processFileDiagnostics(absPath);
        /**
         * Getting emit output for the file
         */
        const output = this.languageService.getEmitOutput(absPath);
        /**
         * Make sure to re-add the module, so that we can track it's imports
         * and reconcile the dependencies tree
         */
        output.outputFiles.forEach((file) => {
            this.referenceTree.add(file.name, this.getSourceImports(file.name, file.text));
        });
        return output;
    }
    /**
     * Process the source file
     */
    async processSourceFile(absPath, relativePath, trigger) {
        /**
         * Update the source files manager to add the new file or
         * bump it's version.
         *
         * Bumping the version is important, so that the typescript compiler
         * referencing the source files manager should re-read the file
         * from disk
         */
        if (trigger === 'add') {
            this.sourceFilesManager.add(absPath);
        }
        else {
            this.sourceFilesManager.bumpVersion(absPath);
        }
        const output = this.reBuildSourceFile(absPath);
        /**
         * Write files to the disk, when the emitting
         * is enabled
         */
        if (!output.emitSkipped) {
            await Promise.all(output.outputFiles.map((one) => {
                return (0, fs_extra_1.outputFile)(one.name, one.text, 'utf-8');
            }));
        }
        /**
         * Notify subscribers
         */
        this.emit('subsequent:build', {
            absPath,
            relativePath,
            skipped: output.emitSkipped,
            diagnostics: this.diagnosticsStore.toJSON(),
        });
        /**
         * Re-build source file dependencies, since the changes in the public
         * API may impact the dependencies as well
         */
        const dependencies = this.referenceTree.getDependencies(absPath);
        dependencies.forEach((dependency) => this.reBuildSourceFile(dependency));
    }
    /**
     * Invoked when chokidar notifies for a new file addtion
     */
    onNewFile(filePath) {
        const absPath = (0, path_1.join)(this.cwd, filePath);
        if (!this.isScriptFile(filePath) || !this.sourceFilesManager.isSourceFile(absPath)) {
            debug('new file added "%s"', filePath);
            this.emit('add', { relativePath: filePath, absPath });
            return;
        }
        debug('new source file added "%s"', filePath);
        this.processSourceFile(absPath, filePath, 'add');
    }
    /**
     * Invoked when chokidar notifies for changes the existing
     * source file
     */
    onChange(filePath) {
        const absPath = (0, path_1.join)(this.cwd, filePath);
        if (!this.isScriptFile(filePath) || !this.sourceFilesManager.isSourceFile(absPath)) {
            debug('file changed "%s"', filePath);
            this.emit('change', { relativePath: filePath, absPath });
            return;
        }
        debug('source file changed "%s"', filePath);
        this.processSourceFile(absPath, filePath, 'change');
    }
    /**
     * Invoked when chokidar notifies for file deletion
     */
    onRemove(filePath) {
        const absPath = (0, path_1.join)(this.cwd, filePath);
        if (!this.isScriptFile(filePath) || !this.sourceFilesManager.isSourceFile(absPath)) {
            debug('file removed "%s"', filePath);
            this.emit('unlink', { relativePath: filePath, absPath });
            return;
        }
        debug('source file removed "%s"', filePath);
        /**
         * Clean up tracking for a given file
         */
        this.sourceFilesManager.remove(absPath);
        this.diagnosticsStore.remove(absPath);
        this.referenceTree.remove(absPath);
        /**
         * Notify subscribers
         */
        this.emit('source:unlink', { relativePath: filePath, absPath });
    }
    /**
     * Build and watch project for changes
     */
    watch(watchPattern = ['.'], watcherOptions) {
        const builder = new Builder_1.Builder(this.ts, this.config, this.pluginManager);
        const buildResponse = builder.build();
        this.host = builder.host;
        this.program = builder.program;
        this.compilerOptions = builder.compilerOptions;
        this.initiateSourceFileManager(this.config);
        this.initiateDiagnosticsStore(buildResponse.diagnostics);
        this.initiateModuleResolver();
        this.initiateReferenceTree();
        this.initiateWatcher(watchPattern, watcherOptions);
        this.chokidar.on('ready', () => {
            debug('watcher ready');
            this.emit('watcher:ready');
            this.initiateLanguageService(this.config.options);
        });
        this.chokidar.on('add', (path) => this.onNewFile(path));
        this.chokidar.on('change', (path) => this.onChange(path));
        this.chokidar.on('unlink', (path) => this.onRemove(path));
        return buildResponse;
    }
}
exports.LspWatcher = LspWatcher;
