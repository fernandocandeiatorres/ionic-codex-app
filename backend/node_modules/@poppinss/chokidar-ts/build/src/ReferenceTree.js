"use strict";
/*
 * @poppinss/chokidar-ts
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReferenceTree = void 0;
const debug_1 = __importDefault(require("debug"));
const path_1 = require("path");
const debug = (0, debug_1.default)('tsc:reference:tree');
/**
 * Reference tree exposes the API to track files along with their
 * dependencies. Here dependencies are the imported files fetched
 * using the Typescript compiler API.
 *
 * The reference tree is optimized to fetch a list of files dependent on
 * a given file.
 */
class ReferenceTree {
    constructor() {
        this.tree = new Map();
        this.imports = new Map();
        debug('initiating reference tree');
    }
    /**
     * Creates the top level node in the depdencies map
     */
    addDependencyNode(modulePath) {
        if (!this.tree.has(modulePath)) {
            this.tree.set(modulePath, new Set());
        }
    }
    /**
     * Adds the dependency on the module node
     */
    addDependency(dependencyPath, importRef) {
        this.addDependencyNode(dependencyPath);
        debug('adding "%s" as dependency for "%s" module', dependencyPath, importRef.modulePath);
        this.tree.get(dependencyPath).add(importRef);
    }
    /**
     * Updates the import verion
     */
    bumpVersion(modulePath) {
        const oldVersion = this.imports.get(modulePath);
        this.imports.set(modulePath, {
            version: oldVersion ? oldVersion.version++ : 1,
            modulePath,
        });
    }
    /**
     * Add a new module to the tree along with it's imports
     */
    add(modulePath, importReferences) {
        if (!(0, path_1.isAbsolute)(modulePath)) {
            throw new Error('ReferenceTree.add requires absolute path for the tracking file');
        }
        /**
         * Create node in the imports tree
         */
        this.bumpVersion(modulePath);
        const importRef = this.imports.get(modulePath);
        importReferences.forEach((reference) => this.addDependency(reference, importRef));
    }
    /**
     * Remove module
     */
    remove(modulePath) {
        debug('removing module "%s"', modulePath);
        this.imports.delete(modulePath);
    }
    /**
     * Returns an array of dependencies for a given module
     */
    getDependencies(modulePath) {
        const dependenciesRefs = this.tree.get(modulePath);
        if (!dependenciesRefs) {
            return [];
        }
        const serialized = [];
        dependenciesRefs.forEach((ref) => {
            const originalRef = this.imports.get(ref.modulePath);
            /**
             * Cleaning up non existing dependencies
             */
            if (!originalRef) {
                dependenciesRefs.delete(ref);
                return;
            }
            /**
             * Cleaning up stale nodes
             */
            if (originalRef.version !== ref.version) {
                dependenciesRefs.delete(ref);
                return;
            }
            serialized.push(ref.modulePath);
        });
        debug('module "%s" has following dependencies %j', modulePath, serialized);
        return serialized;
    }
    /**
     * Serializes tree to an object
     */
    toJSON() {
        const serialized = {};
        this.tree.forEach((_, modulePath) => {
            const dependencies = this.getDependencies(modulePath);
            if (dependencies.length) {
                serialized[modulePath] = dependencies;
            }
        });
        return serialized;
    }
}
exports.ReferenceTree = ReferenceTree;
