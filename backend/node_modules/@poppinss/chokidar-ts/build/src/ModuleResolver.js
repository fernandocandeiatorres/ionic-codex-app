"use strict";
/*
 * @poppinss/chokidar-ts
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleResolver = void 0;
const debug_1 = __importDefault(require("debug"));
const builtin_modules_1 = __importDefault(require("builtin-modules"));
const debug = (0, debug_1.default)('tsc:module:resolver');
/**
 * Wraps the typescript compiler `nodeModuleNameResolver` to ignore the
 * native modules and dependencies. Since, we need module resolver
 * to report type errors, we do not type check node_modules when
 * they are changed during the watch mode.
 */
class ModuleResolver {
    constructor(ts, compilerOptions) {
        this.ts = ts;
        this.compilerOptions = compilerOptions;
        this.ignoreList = new Set(builtin_modules_1.default);
        this.ambientModules = new Map();
    }
    /**
     * Track ambient module
     */
    addAmbientModules(filePath, ambientModules) {
        ambientModules.forEach((ambientModule) => this.ambientModules.set(ambientModule, filePath));
    }
    /**
     * Returns the resolved module path
     */
    resolve(importPath, modulePath) {
        if (this.ignoreList.has(importPath)) {
            debug('ignoring module "%s"', importPath);
            return null;
        }
        /**
         * Resolve ambientModuleFilePath when imports is tracked as ambient
         * module already
         */
        const ambientModuleFilePath = this.ambientModules.get(importPath);
        if (ambientModuleFilePath) {
            return ambientModuleFilePath;
        }
        const resolved = this.ts.resolveModuleName(importPath, modulePath, this.compilerOptions, this.ts.sys);
        /**
         * Return null when unable to resolve the module or the module extension
         * is not ts
         */
        if (!resolved.resolvedModule || resolved.resolvedModule.extension !== '.ts') {
            return null;
        }
        /**
         * Ignore node module packages
         */
        if (resolved.resolvedModule.packageId) {
            debug('adding node module "%s" to ignore list', importPath);
            this.ignoreList.add(importPath);
            return null;
        }
        return resolved.resolvedModule.resolvedFileName;
    }
}
exports.ModuleResolver = ModuleResolver;
